#!/usr/bin/env python

# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT license.

import os
import sys
import argparse
from os.path import join as pjoin

import numpy as np

import textworld
import textworld.challenges

from textworld.generator import TextworldNoSuchQuestExistError


MAX_BREADTH = 5
MAX_DEPTH = 5
MAX_LENGTH = 5


def _get_available_challenges():
    challenges = []
    for challenge in textworld.challenges.CHALLENGES:
        challenges.append("tw-{}-level{{N}}".format(challenge))

    return challenges


def exit_listing_challenges(challenge=None):
    msg = ""
    if challenge is not None:
        msg += "Unknown challenge: {}\n\n".format(args.challenge)

    msg += "Available challenges:\n  "
    msg += "\n  ".join(_get_available_challenges())
    msg += "\nwhere {N} is an integer."
    print(msg)
    sys.exit(1)


def parse_args():
    general_parser = argparse.ArgumentParser(add_help=False)

    general_group = general_parser.add_argument_group('General settings')
    general_group.add_argument("--output", default="./tw_games/", metavar="PATH",
                               help="Path where to save the generated game.")
    general_group.add_argument('--seed', type=int)
    general_group.add_argument('--format', choices=["ulx", "z8"], default="ulx",
                               help="Which format to use when compiling the game. Default: %(default)s")
    general_group.add_argument("--view", action="store_true",
                               help="Display the resulting game.")
    general_group.add_argument("-f", "--force", action="store_true")

    verbosity_group = general_group.add_mutually_exclusive_group()
    verbosity_group.add_argument("--silent", action="store_true")
    verbosity_group.add_argument("-v", "--verbose", action="store_true")

    cfg_group = general_parser.add_argument_group('Grammar settings')
    cfg_group.add_argument("--theme", default="house",
                           help="Theme to use for generating the text. Default: %(default)s")
    cfg_group.add_argument("--include-adj", action="store_true",
                           help="Turn on adjectives.")
    cfg_group.add_argument("--blend-descriptions", action="store_true",
                           help="Blend descriptions across consecutive sentences.")
    cfg_group.add_argument("--ambiguous-instructions", action="store_true",
                           help="Refer to an object using its type (e.g. red container vs. red chest).")
    cfg_group.add_argument("--only-last-action", action="store_true",
                           help="Intruction only describes the last action of quest.")
    cfg_group.add_argument("--blend-instructions", action="store_true",
                           help="Blend instructions across consecutive actions.")

    parser = argparse.ArgumentParser(parents=[general_parser])
    subparsers = parser.add_subparsers(dest="subcommand", help='Kind of game to make.')

    custom_parser = subparsers.add_parser("custom", parents=[general_parser],
                                          help='Make a custom game.')
    custom_parser.add_argument("--world-size", type=int, default=5, metavar="SIZE",
                               help="Nb. of rooms in the world.")
    custom_parser.add_argument("--nb-objects", type=int, default=10, metavar="NB",
                               help="Nb. of objects in the world.")

    quest_group = custom_parser.add_argument_group('Quest settings')
    quest_group.add_argument("--quest-min-length", type=int, default=1, metavar="LENGTH",
                               help="Minimum nb. of actions the quest requires to be completed. Default: %(default)s.")
    quest_group.add_argument("--quest-max-length", type=int, default=5, metavar="LENGTH",
                               help="Maximum nb. of actions the quest requires to be completed."
                                    " Default: {} unless --quest-depth or --quest-breadth are specified.".format(MAX_LENGTH))
    quest_group.add_argument("--quest-length", type=int, metavar="LENGTH",
                               help="Nb. of actions the quest requires to be completed.")

    quest_group.add_argument("--quest-min-depth", type=int, default=1, metavar="DEPTH",
                               help="Minimum nb. of actions the subquests can have. Default: %(default)s.")
    quest_group.add_argument("--quest-max-depth", type=int, metavar="DEPTH",
                               help="Maximum nb. of actions the subquests can have."
                                    " Default: {} unless --quest-length is specified.".format(MAX_DEPTH))
    quest_group.add_argument("--quest-depth", type=int, metavar="DEPTH",
                               help="Nb. of actions the subquests will have.")

    quest_group.add_argument("--quest-min-breadth", type=int, default=1, metavar="BREADTH",
                               help="Minimum nb. of subquests the quests can have. Default: %(default)s.")
    quest_group.add_argument("--quest-max-breadth", type=int, metavar="BREADTH",
                               help="Maxmimum nb. of subquests the quests can have."
                                    " Default: {} unless --quest-length is specified.".format(MAX_BREADTH))
    quest_group.add_argument("--quest-breadth", type=int, metavar="BREADTH",
                               help="Nb. of subquests the quests will have.")

    quest_group.add_argument("--nb-parallel-quests", type=int, default=1,
                               help="Nb. of parallel quests the game will have. Default: %(default)s.")

    challenge_parser = subparsers.add_parser("challenge", parents=[general_parser],
                                             help='Generate a game for one of the challenges.')
    challenge_parser.add_argument("challenge",
                                  help="Name of the builtin challenges, e.g. `tw-coin_collector-level210`")

    return parser.parse_args(), parser


if __name__ == "__main__":
    args, parser = parse_args()
    if args.seed is None:
        args.seed = np.random.randint(65635)

    if not args.silent:
        print("Global seed: {}".format(args.seed))

    options = textworld.GameOptions()
    options.seeds = args.seed
    options.path = args.output
    options.file_ext = "." + args.format
    options.force_recompile = args.force
    options.grammar.theme = args.theme
    options.grammar.include_adj = args.include_adj
    options.grammar.only_last_action = args.only_last_action
    options.grammar.blend_instructions = args.blend_instructions
    options.grammar.blend_descriptions = args.blend_descriptions
    options.grammar.ambiguous_instructions = args.ambiguous_instructions

    if args.subcommand == "custom":
        options.nb_rooms = args.world_size
        options.nb_objects = args.nb_objects
        options.chaining.min_breadth = args.quest_min_breadth
        options.chaining.min_depth = args.quest_min_depth
        options.chaining.min_length = args.quest_min_length
        options.nb_parallel_quests = args.nb_parallel_quests

        if args.quest_length:
            options.quest_length = args.quest_length
        else:
            args.quest_max_depth = MAX_DEPTH
            args.quest_max_breadth = MAX_BREADTH

        if args.quest_breadth:
            options.quest_breadth = args.quest_breadth
        else:
            args.quest_max_length = MAX_LENGTH

        if args.quest_depth:
            options.quest_depth = args.quest_depth
        else:
            args.quest_max_length = MAX_LENGTH

        if args.quest_max_breadth:
            options.chaining.max_breadth = args.quest_max_breadth

        if args.quest_max_depth:
            options.chaining.max_depth = args.quest_max_depth

        if args.quest_max_length:
            options.chaining.max_length = args.quest_max_length

        try:
            game_file, game = textworld.make(options)
        except TextworldNoSuchQuestExistError:
            # TODO: Display current values of `options` to help understanding why no game could be generated.
            msg = ("No quest can be generated with the provided options."
                   " Try relaxing the quest generation constraints, e.g."
                   " using `--quest-min-length` instead of `--quest-length`.")
            parser.error(msg)

    elif args.subcommand == "challenge":
        try:
            # Expected pattern: "tw-challenge-levelN"
            _, challenge, level = args.challenge.split("-")
        except ValueError:
            exit_listing_challenges()

        if challenge not in textworld.challenges.CHALLENGES:
            exit_listing_challenges(args.challenge)

        level = int(level.lstrip("level"))
        make_game = textworld.challenges.CHALLENGES[challenge]
        game = make_game(level, options)
        game_file = textworld.generator.compile_game(game, options)

    if not args.silent:
        print("Game generated: {}".format(game_file))

    if args.verbose:
        print(game.objective)
        print(" > ".join(game.main_quest.commands))

    if args.view:
        textworld.render.visualize(game, interactive=True)
