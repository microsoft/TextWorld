# # door
# type d : t {
#     predicates {
#         open(d);
#         closed(d);
#         locked(d);

#         link(r, d, r);
#     }

#     rules {
#         lock/d          :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & closed(d) -> locked(d);
#         unlock/d        :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & $in(k, I) & $match(k, d) & locked(d) -> closed(d);

#         open/d          :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & closed(d) -> open(d) & free(r, r') & free(r', r);
#         close/d         :: $at(P, r) & $link(r, d, r') & $link(r', d, r) & open(d) & free(r, r') & free(r', r) -> closed(d);
        
#         lock/close/db   :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & pushed(b) & open(d) & free(r, r') & free(r', r) -> unpushed(b) & locked(d);
#         unlock/open/db  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r, r') & free(r', r);

#         lock/close/d/b  :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r', d, r'') & $link(r'', d, r') & pushed(b) & open(d) & free(r', r'') & free(r'', r') -> unpushed(b) & locked(d);
#         unlock/open/d/b :: $at(P, r) & $at(s, r) & $on(c, s) & $open(c) & $in(b, c) & $pair(b, d) & $link(r', d, r'') & $link(r'', d, r') & unpushed(b) & locked(d) -> pushed(b) & open(d) & free(r', r'') & free(r'', r');

#         examine/d       :: at(P, r) & $link(r, d, r') -> at(P, r);  # Nothing changes.
#     }

#     reverse_rules {
#         lock/d :: unlock/d;
#         open/d :: close/d;
#         lock/close/d/b :: unlock/open/d/b;
#         lock/close/db :: unlock/open/db;
#     }

#     constraints {
#         d1 :: open(d)   & closed(d) -> fail();
#         d2 :: open(d)   & locked(d) -> fail();
#         d3 :: closed(d) & locked(d) -> fail();

#         # A door can't be used to link more than two rooms.
#         link1          :: link(r, d, r') & link(r, d, r'') -> fail();
#         link2          :: link(r, d, r') & link(r'', d, r''') -> fail();

#         # There's already a door linking two rooms.
#         link3          :: link(r, d, r') & link(r, d', r') -> fail();

#         # There cannot be more than four doors in a room.
#         too_many_doors :: link(r, d1: d, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();

#         # There cannot be more than four doors in a room.
#         dr1   :: free(r, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
#         dr2   :: free(r, r1: r) & free(r, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
#         dr3   :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
#         dr4   :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & free(r, r4: r) & link(r, d5: d, r5: r) -> fail();

#         free1 :: link(r, d, r') & free(r, r') & closed(d) -> fail();
#         free2 :: link(r, d, r') & free(r, r') & locked(d) -> fail();
#     }

#     inform7 {
#         type {
#             kind       :: "door";
#             definition :: "door is openable and lockable.";
#         }

#         predicates {
#             open(d)         :: "The {d} is open";
#             closed(d)       :: "The {d} is closed";
#             locked(d)       :: "The {d} is locked";
            
#             link(r, d, r')  :: "";  # No equivalent in Inform7.
#         }

#         commands {
#             open/d          :: "open {d}"            :: "opening {d}";
#             close/d         :: "close {d}"           :: "closing {d}";

#             unlock/d        :: "unlock {d} with {k}" :: "unlocking {d} with the {k}";
#             lock/d          :: "lock {d} with {k}"   :: "locking {d} with the {k}";

#             lock/close/d/b  :: "push {b}"            :: "_pushing the {b}";
#             unlock/open/d/b :: "push {b}"            :: "_pushing the {b}";

#             lock/close/db   :: "push {b}"            :: "_pushing the {b}";
#             unlock/open/db  :: "push {b}"            :: "_pushing the {b}";

#             examine/d       :: "examine {d}"         :: "examining the {d}";
#         }
#     }
# }
