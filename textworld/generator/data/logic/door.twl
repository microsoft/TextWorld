# door
type d : t, lockable {
    predicates {
        link(r, d, r);

        north_of/d(r, d, r);
        west_of/d(r, d, r);

        south_of/d(r, d, r') = north_of/d(r', d, r);
        east_of/d(r, d, r') = west_of/d(r', d, r);

        reachable(d) = at(P, r) & link(r, d, r') & link(r', d, r);
    }

    rules {
        lock(d, k)   :: $reachable(d) & $in(k, I) & $match(k, d) & closed(d) -> locked(d);
        unlock(d, k) :: $reachable(d) & $in(k, I) & $match(k, d) & locked(d) -> closed(d);

        open(d)   :: $reachable(d) & closed(d) -> open(d) & free(r, r') & free(r', r);
        close(d)  :: $reachable(d) & open(d) & free(r, r') & free(r', r) -> closed(d);
    }

    reverse_rules {
        lock(d, k) :: unlock(d, k);
        open(d) :: close(d);
    }

    constraints {
        # A door can't be used to link more than two rooms.
        link1 :: link(r, d, r') & link(r, d, r'') -> fail();
        link2 :: link(r, d, r') & link(r'', d, r''') -> fail();

        # There's already a door linking two rooms.
        link3 :: link(r, d, r') & link(r, d', r') -> fail();

        # There cannot be more than four doors in a room.
        too_many_doors :: link(r, d1: d, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();

        # There cannot be more than four doors in a room.
        dr1 :: free(r, r1: r) & link(r, d2: d, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
        dr2 :: free(r, r1: r) & free(r, r2: r) & link(r, d3: d, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
        dr3 :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & link(r, d4: d, r4: r) & link(r, d5: d, r5: r) -> fail();
        dr4 :: free(r, r1: r) & free(r, r2: r) & free(r, r3: r) & free(r, r4: r) & link(r, d5: d, r5: r) -> fail();

        free1 :: link(r, d, r') & free(r, r') & closed(d) -> fail();
        free2 :: link(r, d, r') & free(r, r') & locked(d) -> fail();
    }

    inform7 {
        type {
            kind :: "door";
            definition :: "door is openable and lockable.";
        }

        commands {
            open(d) :: "open {d}" :: "opening {d}";
            close(d) :: "close {d}" :: "closing {d}";

            unlock(d, k) :: "unlock {d} with {k}" :: "unlocking {d} with the {k}";
            lock(d, k) :: "lock {d} with {k}" :: "locking {d} with the {k}";
        }

        predicates {
            north_of/d(r, d, r') :: "South of {r} and north of {r'} is a door called {d}";
            south_of/d(r, d, r') :: "North of {r} and south of {r'} is a door called {d}";
            east_of/d(r, d, r') :: "West of {r} and east of {r'} is a door called {d}";
            west_of/d(r, d, r') :: "East of {r} and west of {r'} is a door called {d}";
        }
    }
}
